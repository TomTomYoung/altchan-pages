<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Advanced Mathematical Drawing System</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }
        
        h1 {
            text-align: center;
            color: #333;
            font-size: 2.5em;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #495057;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        
        input, select, textarea {
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        #commandInput {
            width: 100%;
            height: 100px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 13px;
            resize: vertical;
        }
        
        .canvas-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        
        canvas {
            border: 3px solid #dee2e6;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            background: white;
        }
        
        .sidebar {
            min-width: 300px;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }
        
        .examples {
            margin-top: 20px;
        }
        
        .example {
            background: white;
            padding: 10px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .example:hover {
            transform: translateX(5px);
            box-shadow: 0 3px 10px rgba(0,0,0,0.1);
        }
        
        .variables {
            background: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        .animation-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        #colorPicker {
            width: 50px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
        
        .status {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        
        @media (max-width: 1200px) {
            .canvas-container {
                flex-direction: column;
            }
            .controls {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🎨 Advanced Mathematical Drawing System</h1>
        
        <div class="controls">
            <div class="control-group">
                <h3>📝 Command Input</h3>
                <textarea id="commandInput" placeholder="例: line(0,0,100,100,'red',3)
circle(50,50,30,'blue',true)
plot('sin(x)',-10,10,'green')
animate('cos(t)*100',0,0,'red')"></textarea>
                <div class="input-row">
                    <button onclick="executeCommands()">🚀 実行</button>
                    <button onclick="clearCanvas()">🗑️ クリア</button>
                    <button onclick="saveCanvas()">💾 保存</button>
                    <button onclick="toggleAnimation()">▶️ アニメーション</button>
                </div>
            </div>
            
            <div class="control-group">
                <h3>🎛️ Drawing Controls</h3>
                <div class="input-row">
                    <input type="color" id="colorPicker" value="#000000">
                    <input type="range" id="lineWidth" min="1" max="20" value="2">
                    <span>線の太さ: <span id="lineWidthValue">2</span></span>
                </div>
                <div class="input-row">
                    <input type="number" id="gridSize" value="50" placeholder="グリッドサイズ">
                    <button onclick="toggleGrid()">📐 グリッド</button>
                    <button onclick="toggleAxes()">📏 軸</button>
                </div>
                <div class="animation-controls">
                    <button onclick="pauseAnimation()">⏸️ 一時停止</button>
                    <button onclick="resetAnimation()">🔄 リセット</button>
                    <input type="range" id="animSpeed" min="0.1" max="5" step="0.1" value="1">
                    <span>速度</span>
                </div>
            </div>
        </div>
        
        <div class="canvas-container">
            <canvas id="canvas" width="1000" height="700"></canvas>
            
            <div class="sidebar">
                <h3>📊 Variables</h3>
                <div class="variables" id="variables"></div>
                
                <div class="examples">
                    <h3>💡 Examples</h3>
                    <div class="example" onclick="loadExample(0)">
                        <strong>基本図形</strong><br>
                        <small>円、線、矩形の描画</small>
                    </div>
                    <div class="example" onclick="loadExample(1)">
                        <strong>三角関数</strong><br>
                        <small>sin, cos, tan のグラフ</small>
                    </div>
                    <div class="example" onclick="loadExample(2)">
                        <strong>パラメトリック曲線</strong><br>
                        <small>リサージュ曲線、螺旋など</small>
                    </div>
                    <div class="example" onclick="loadExample(3)">
                        <strong>フラクタル</strong><br>
                        <small>シェルピンスキーの三角形</small>
                    </div>
                    <div class="example" onclick="loadExample(4)">
                        <strong>物理シミュレーション</strong><br>
                        <small>振り子、波動</small>
                    </div>
                    <div class="example" onclick="loadExample(5)">
                        <strong>複素数平面</strong><br>
                        <small>複素関数の可視化</small>
                    </div>
                </div>
                
                <div id="status" class="status"></div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedSystem {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext("2d");
                this.origin = { x: this.canvas.width / 2, y: this.canvas.height / 2 };
                this.invY = true;
                this.scale = 1;
                this.gridVisible = false;
                this.axesVisible = true;
                this.animationId = null;
                this.animationTime = 0;
                this.animationSpeed = 1;
                this.variables = new Map();
                this.functions = new Map();
                this.animatedObjects = [];
                this.isAnimating = false;
                this.setupEventListeners();
            }

            setupEventListeners() {
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    this.scale *= scaleFactor;
                    
                    // Zoom towards mouse position
                    this.origin.x = x - (x - this.origin.x) * scaleFactor;
                    this.origin.y = y - (y - this.origin.y) * scaleFactor;
                    
                    this.redraw();
                });

                let isDragging = false;
                let lastMouse = { x: 0, y: 0 };

                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastMouse.x = e.clientX;
                    lastMouse.y = e.clientY;
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const dx = e.clientX - lastMouse.x;
                        const dy = e.clientY - lastMouse.y;
                        this.origin.x += dx;
                        this.origin.y += dy;
                        lastMouse.x = e.clientX;
                        lastMouse.y = e.clientY;
                        this.redraw();
                    }
                });

                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });
            }

            toCanvasCoords(x, y) {
                const cx = this.origin.x + x * this.scale;
                const cy = this.origin.y + (this.invY ? -y : y) * this.scale;
                return { x: cx, y: cy };
            }

            fromCanvasCoords(cx, cy) {
                const x = (cx - this.origin.x) / this.scale;
                const y = this.invY ? -(cy - this.origin.y) / this.scale : (cy - this.origin.y) / this.scale;
                return { x, y };
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            drawGrid() {
                if (!this.gridVisible) return;
                
                const gridSize = parseInt(document.getElementById('gridSize').value) * this.scale;
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 1;
                
                // Vertical lines
                for (let x = this.origin.x % gridSize; x < this.canvas.width; x += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Horizontal lines
                for (let y = this.origin.y % gridSize; y < this.canvas.height; y += gridSize) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            drawAxes() {
                if (!this.axesVisible) return;
                
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                
                // X-axis
                this.ctx.beginPath();
                this.ctx.moveTo(0, this.origin.y);
                this.ctx.lineTo(this.canvas.width, this.origin.y);
                this.ctx.stroke();
                
                // Y-axis
                this.ctx.beginPath();
                this.ctx.moveTo(this.origin.x, 0);
                this.ctx.lineTo(this.origin.x, this.canvas.height);
                this.ctx.stroke();
                
                // Scale indicators
                this.drawScaleIndicators();
            }

            drawScaleIndicators() {
                const step = 50 * this.scale;
                const minStep = 20;
                
                if (step < minStep) return;
                
                this.ctx.fillStyle = '#666';
                this.ctx.font = '12px Arial';
                this.ctx.textAlign = 'center';
                
                // X-axis indicators
                for (let x = this.origin.x; x < this.canvas.width; x += step) {
                    if (x !== this.origin.x) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, this.origin.y - 5);
                        this.ctx.lineTo(x, this.origin.y + 5);
                        this.ctx.stroke();
                        
                        const worldX = Math.round((x - this.origin.x) / this.scale);
                        if (worldX !== 0) {
                            this.ctx.fillText(worldX.toString(), x, this.origin.y + 20);
                        }
                    }
                }
                
                for (let x = this.origin.x; x > 0; x -= step) {
                    if (x !== this.origin.x) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(x, this.origin.y - 5);
                        this.ctx.lineTo(x, this.origin.y + 5);
                        this.ctx.stroke();
                        
                        const worldX = Math.round((x - this.origin.x) / this.scale);
                        if (worldX !== 0) {
                            this.ctx.fillText(worldX.toString(), x, this.origin.y + 20);
                        }
                    }
                }
                
                // Y-axis indicators
                this.ctx.textAlign = 'right';
                for (let y = this.origin.y; y < this.canvas.height; y += step) {
                    if (y !== this.origin.y) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.origin.x - 5, y);
                        this.ctx.lineTo(this.origin.x + 5, y);
                        this.ctx.stroke();
                        
                        const worldY = Math.round(-(y - this.origin.y) / this.scale);
                        if (worldY !== 0) {
                            this.ctx.fillText(worldY.toString(), this.origin.x - 10, y + 4);
                        }
                    }
                }
                
                for (let y = this.origin.y; y > 0; y -= step) {
                    if (y !== this.origin.y) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(this.origin.x - 5, y);
                        this.ctx.lineTo(this.origin.x + 5, y);
                        this.ctx.stroke();
                        
                        const worldY = Math.round(-(y - this.origin.y) / this.scale);
                        if (worldY !== 0) {
                            this.ctx.fillText(worldY.toString(), this.origin.x - 10, y + 4);
                        }
                    }
                }
            }

            // Basic drawing functions
            line(x1, y1, x2, y2, color = "black", width = 1) {
                const p1 = this.toCanvasCoords(x1, y1);
                const p2 = this.toCanvasCoords(x2, y2);
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.lineTo(p2.x, p2.y);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                this.ctx.stroke();
            }

            circle(x, y, r, color = "black", fill = false, width = 1) {
                const p = this.toCanvasCoords(x, y);
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, r * this.scale, 0, Math.PI * 2);
                this.ctx.lineWidth = width;
                if (fill) {
                    this.ctx.fillStyle = color;
                    this.ctx.fill();
                } else {
                    this.ctx.strokeStyle = color;
                    this.ctx.stroke();
                }
            }

            rect(x, y, w, h, color = "black", fill = false, width = 1) {
                const p = this.toCanvasCoords(x, y);
                this.ctx.lineWidth = width;
                if (fill) {
                    this.ctx.fillStyle = color;
                    this.ctx.fillRect(p.x, p.y, w * this.scale, -h * this.scale);
                } else {
                    this.ctx.strokeStyle = color;
                    this.ctx.strokeRect(p.x, p.y, w * this.scale, -h * this.scale);
                }
            }

            point(x, y, color = "black", size = 3) {
                this.circle(x, y, size, color, true);
            }

            text(x, y, txt, color = "black", size = 12) {
                const p = this.toCanvasCoords(x, y);
                this.ctx.fillStyle = color;
                this.ctx.font = `${size}px Arial`;
                this.ctx.fillText(txt, p.x, p.y);
            }

            // Advanced drawing functions
            arrow(x1, y1, x2, y2, color = "black", width = 1) {
                this.line(x1, y1, x2, y2, color, width);
                
                const angle = Math.atan2(y2 - y1, x2 - x1);
                const headlen = 10;
                
                const x3 = x2 - headlen * Math.cos(angle - Math.PI / 6);
                const y3 = y2 - headlen * Math.sin(angle - Math.PI / 6);
                const x4 = x2 - headlen * Math.cos(angle + Math.PI / 6);
                const y4 = y2 - headlen * Math.sin(angle + Math.PI / 6);
                
                this.line(x2, y2, x3, y3, color, width);
                this.line(x2, y2, x4, y4, color, width);
            }

            polygon(points, color = "black", fill = false, width = 1) {
                if (points.length < 2) return;
                
                const p0 = this.toCanvasCoords(points[0].x, points[0].y);
                this.ctx.beginPath();
                this.ctx.moveTo(p0.x, p0.y);
                
                for (let i = 1; i < points.length; i++) {
                    const p = this.toCanvasCoords(points[i].x, points[i].y);
                    this.ctx.lineTo(p.x, p.y);
                }
                
                this.ctx.closePath();
                this.ctx.lineWidth = width;
                
                if (fill) {
                    this.ctx.fillStyle = color;
                    this.ctx.fill();
                } else {
                    this.ctx.strokeStyle = color;
                    this.ctx.stroke();
                }
            }

            // Mathematical function plotting
            plot(func, xMin, xMax, color = "black", width = 1, steps = 1000) {
                const dx = (xMax - xMin) / steps;
                let firstPoint = true;
                
                this.ctx.beginPath();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + i * dx;
                    try {
                        const y = this.evaluateExpression(func, { x, t: this.animationTime });
                        if (isFinite(y)) {
                            const p = this.toCanvasCoords(x, y);
                            if (firstPoint) {
                                this.ctx.moveTo(p.x, p.y);
                                firstPoint = false;
                            } else {
                                this.ctx.lineTo(p.x, p.y);
                            }
                        } else {
                            firstPoint = true;
                        }
                    } catch (e) {
                        firstPoint = true;
                    }
                }
                
                this.ctx.stroke();
            }

            parametric(xFunc, yFunc, tMin, tMax, color = "black", width = 1, steps = 1000) {
                const dt = (tMax - tMin) / steps;
                let firstPoint = true;
                
                this.ctx.beginPath();
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                
                for (let i = 0; i <= steps; i++) {
                    const t = tMin + i * dt;
                    try {
                        const x = this.evaluateExpression(xFunc, { t, time: this.animationTime });
                        const y = this.evaluateExpression(yFunc, { t, time: this.animationTime });
                        
                        if (isFinite(x) && isFinite(y)) {
                            const p = this.toCanvasCoords(x, y);
                            if (firstPoint) {
                                this.ctx.moveTo(p.x, p.y);
                                firstPoint = false;
                            } else {
                                this.ctx.lineTo(p.x, p.y);
                            }
                        } else {
                            firstPoint = true;
                        }
                    } catch (e) {
                        firstPoint = true;
                    }
                }
                
                this.ctx.stroke();
            }

            // Expression evaluator
            evaluateExpression(expr, vars = {}) {
                // Replace common mathematical functions
                let processedExpr = expr
                    .replace(/sin\(/g, 'Math.sin(')
                    .replace(/cos\(/g, 'Math.cos(')
                    .replace(/tan\(/g, 'Math.tan(')
                    .replace(/sqrt\(/g, 'Math.sqrt(')
                    .replace(/abs\(/g, 'Math.abs(')
                    .replace(/exp\(/g, 'Math.exp(')
                    .replace(/log\(/g, 'Math.log(')
                    .replace(/pow\(/g, 'Math.pow(')
                    .replace(/floor\(/g, 'Math.floor(')
                    .replace(/ceil\(/g, 'Math.ceil(')
                    .replace(/round\(/g, 'Math.round(')
                    .replace(/PI/g, 'Math.PI')
                    .replace(/E/g, 'Math.E');

                // Replace variables
                Object.entries(vars).forEach(([key, value]) => {
                    const regex = new RegExp(`\\b${key}\\b`, 'g');
                    processedExpr = processedExpr.replace(regex, value.toString());
                });

                // Replace stored variables
                this.variables.forEach((value, key) => {
                    const regex = new RegExp(`\\b${key}\\b`, 'g');
                    processedExpr = processedExpr.replace(regex, value.toString());
                });

                return Function(`"use strict"; return (${processedExpr})`)();
            }

            // Animation system
            animate(callback) {
                if (this.isAnimating) {
                    this.animationTime += 0.016 * this.animationSpeed; // ~60fps
                    callback();
                    this.animationId = requestAnimationFrame(() => this.animate(callback));
                }
            }

            startAnimation() {
                if (!this.isAnimating) {
                    this.isAnimating = true;
                    this.animate(() => this.redraw());
                }
            }

            stopAnimation() {
                this.isAnimating = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            resetAnimation() {
                this.animationTime = 0;
                this.redraw();
            }

            // Command execution
            executeCommand(command) {
                try {
                    // Remove comments
                    command = command.split('//')[0].trim();
                    if (!command) return;

                    // Variable assignment
                    if (command.includes('=') && !command.includes('==')) {
                        const [varName, expression] = command.split('=').map(s => s.trim());
                        const value = this.evaluateExpression(expression, { t: this.animationTime });
                        this.variables.set(varName, value);
                        this.updateVariablesDisplay();
                        return;
                    }

                    // Parse function calls
                    const funcMatch = command.match(/(\w+)\((.*)\)/);
                    if (funcMatch) {
                        const [, funcName, argsStr] = funcMatch;
                        const args = this.parseArguments(argsStr);
                        
                        switch (funcName) {
                            case 'line':
                                this.line(...args);
                                break;
                            case 'circle':
                                this.circle(...args);
                                break;
                            case 'rect':
                                this.rect(...args);
                                break;
                            case 'point':
                                this.point(...args);
                                break;
                            case 'text':
                                this.text(...args);
                                break;
                            case 'arrow':
                                this.arrow(...args);
                                break;
                            case 'plot':
                                this.plot(...args);
                                break;
                            case 'parametric':
                                this.parametric(...args);
                                break;
                            default:
                                throw new Error(`Unknown function: ${funcName}`);
                        }
                    }
                } catch (error) {
                    this.showStatus(`Error: ${error.message}`, 'error');
                }
            }

            parseArguments(argsStr) {
                if (!argsStr.trim()) return [];
                
                const args = [];
                let current = '';
                let inQuotes = false;
                let parenDepth = 0;
                
                for (let i = 0; i < argsStr.length; i++) {
                    const char = argsStr[i];
                    
                    if (char === '"' || char === "'") {
                        inQuotes = !inQuotes;
                        current += char;
                    } else if (char === '(' && !inQuotes) {
                        parenDepth++;
                        current += char;
                    } else if (char === ')' && !inQuotes) {
                        parenDepth--;
                        current += char;
                    } else if (char === ',' && !inQuotes && parenDepth === 0) {
                        args.push(this.processArgument(current.trim()));
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                if (current.trim()) {
                    args.push(this.processArgument(current.trim()));
                }
                
                return args;
            }

            processArgument(arg) {
                // String literals
                if ((arg.startsWith('"') && arg.endsWith('"')) || 
                    (arg.startsWith("'") && arg.endsWith("'"))) {
                    return arg.slice(1, -1);
                }
                
                // Boolean literals
                if (arg === 'true') return true;
                if (arg === 'false') return false;
                
                // Numeric expressions
                try {
                    return this.evaluateExpression(arg, { t: this.animationTime });
                } catch (e) {
                    return arg;
                }
            }

            redraw() {
                this.clear();
                this.drawGrid();
                this.drawAxes();
                
                // Re-execute all commands
                const commands = document.getElementById('commandInput').value;
                this.executeCommands(commands);
            }

            executeCommands(commandsText) {
                const commands = commandsText.split('\n').filter(cmd => cmd.trim());
                for (const command of commands) {
                    this.executeCommand(command);
                }
            }

            updateVariablesDisplay() {
                const varsDiv = document.getElementById('variables');
                varsDiv.innerHTML = '<h4>Variables:</h4>';
                this.variables.forEach((value, key) => {
                    const div = document.createElement('div');
                    div.innerHTML = `<strong>${key}:</strong> ${value}`;
                    varsDiv.appendChild(div);
                });
            }

            showStatus(message, type = 'info') {
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = message;
                statusDiv.className = `status ${type}`;
                setTimeout(() => {
                    statusDiv.textContent = 'Ready';
                    statusDiv.className = 'status';
                }, 3000);
            }

            // Fractal functions
            sierpinski(x, y, size, depth, color = 'black') {
                if (depth === 0) {
                    const points = [
                        { x: x, y: y },
                        { x: x + size, y: y },
                        { x: x + size/2, y: y + size * Math.sqrt(3)/2 }
                    ];
                    this.polygon(points, color, false, 1);
                    return;
                }

                const newSize = size / 2;
                this.sierpinski(x, y, newSize, depth - 1, color);
                this.sierpinski(x + newSize, y, newSize, depth - 1, color);
                this.sierpinski(x + newSize/2, y + newSize * Math.sqrt(3)/2, newSize, depth - 1, color);
            }

            // Complex number visualization
            complexPlane(func, xMin, xMax, yMin, yMax, color = 'black', steps = 50) {
                const stepX = (xMax - xMin) / steps;
                const stepY = (yMax - yMin) / steps;
                
                for (let i = 0; i <= steps; i++) {
                    for (let j = 0; j <= steps; j++) {
                        const re = xMin + i * stepX;
                        const im = yMin + j * stepY;
                        
                        try {
                            // Simple complex function evaluation
                            const result = this.evaluateComplexFunction(func, re, im);
                            if (isFinite(result.magnitude)) {
                                const intensity = Math.min(1, result.magnitude / 2);
                                const hue = (result.phase + Math.PI) / (2 * Math.PI) * 360;
                                this.point(re, im, `hsl(${hue}, 100%, ${50 + intensity * 50}%)`, 2);
                            }
                        } catch (e) {
                            // Skip invalid points
                        }
                    }
                }
            }

            evaluateComplexFunction(func, re, im) {
                // Simple complex function evaluation (z^2, z^3, etc.)
                let realPart, imagPart;
                
                switch (func) {
                    case 'z':
                        realPart = re;
                        imagPart = im;
                        break;
                    case 'z^2':
                        realPart = re * re - im * im;
                        imagPart = 2 * re * im;
                        break;
                    case 'z^3':
                        realPart = re * re * re - 3 * re * im * im;
                        imagPart = 3 * re * re * im - im * im * im;
                        break;
                    default:
                        realPart = re;
                        imagPart = im;
                }
                
                const magnitude = Math.sqrt(realPart * realPart + imagPart * imagPart);
                const phase = Math.atan2(imagPart, realPart);
                
                return { magnitude, phase };
            }
        }

        // Global system instance
        let system;
        
        // Initialize system
        function initSystem() {
            system = new AdvancedSystem("canvas");
            system.showStatus("System initialized!");
            
            // Update line width display
            document.getElementById('lineWidth').oninput = function() {
                document.getElementById('lineWidthValue').textContent = this.value;
            };
            
            // Animation speed control
            document.getElementById('animSpeed').oninput = function() {
                system.animationSpeed = parseFloat(this.value);
            };
        }

        // Command execution functions
        function executeCommands() {
            const commands = document.getElementById('commandInput').value;
            system.clear();
            system.drawGrid();
            system.drawAxes();
            system.executeCommands(commands);
            system.showStatus("Commands executed!");
        }

        function clearCanvas() {
            system.clear();
            system.drawGrid();
            system.drawAxes();
            system.variables.clear();
            system.updateVariablesDisplay();
            system.showStatus("Canvas cleared!");
        }

        function saveCanvas() {
            const link = document.createElement('a');
            link.download = 'drawing.png';
            link.href = system.canvas.toDataURL();
            link.click();
            system.showStatus("Canvas saved!");
        }

        function toggleAnimation() {
            if (system.isAnimating) {
                system.stopAnimation();
                system.showStatus("Animation stopped");
            } else {
                system.startAnimation();
                system.showStatus("Animation started");
            }
        }

        function pauseAnimation() {
            system.stopAnimation();
            system.showStatus("Animation paused");
        }

        function resetAnimation() {
            system.resetAnimation();
            system.showStatus("Animation reset");
        }

        function toggleGrid() {
            system.gridVisible = !system.gridVisible;
            system.redraw();
            system.showStatus(`Grid ${system.gridVisible ? 'enabled' : 'disabled'}`);
        }

        function toggleAxes() {
            system.axesVisible = !system.axesVisible;
            system.redraw();
            system.showStatus(`Axes ${system.axesVisible ? 'enabled' : 'disabled'}`);
        }

        // Example commands
        const examples = [
            // Basic shapes
            `// Basic Shapes
circle(0, 0, 50, 'blue', false, 2)
rect(-25, -25, 50, 50, 'red', false, 2)
line(-100, -100, 100, 100, 'green', 3)
point(0, 0, 'black', 5)
text(60, 60, 'Hello World!', 'purple', 16)
arrow(-50, 50, 50, -50, 'orange', 2)`,

            // Trigonometric functions
            `// Trigonometric Functions
plot('sin(x)', -10, 10, 'red', 2)
plot('cos(x)', -10, 10, 'blue', 2)
plot('tan(x)', -3, 3, 'green', 2)
line(-10, 0, 10, 0, 'gray', 1)
line(0, -5, 0, 5, 'gray', 1)
text(-9, 1.5, 'sin(x)', 'red', 12)
text(-9, 1, 'cos(x)', 'blue', 12)`,

            // Parametric curves
            `// Parametric Curves - Lissajous
parametric('100*cos(3*t)', '100*sin(2*t)', 0, 6.28, 'purple', 2)
parametric('50*cos(t)', '50*sin(t)', 0, 6.28, 'red', 1)
// Spiral
parametric('t*cos(t)', 't*sin(t)', 0, 20, 'blue', 2)
circle(0, 0, 200, 'lightgray', false, 1)`,

            // Fractal
            `// Sierpinski Triangle Approximation
r = 100
// Triangle vertices
line(-r, -r*0.577, r, -r*0.577, 'black', 2)
line(-r, -r*0.577, 0, r*1.155, 'black', 2)
line(r, -r*0.577, 0, r*1.155, 'black', 2)
// Inner triangles
line(-r/2, 0, r/2, 0, 'red', 1)
line(-r/4, r*0.289, r/4, r*0.289, 'red', 1)
line(0, -r*0.289, -r/2, 0, 'red', 1)
line(0, -r*0.289, r/2, 0, 'red', 1)`,

            // Physics simulation
            `// Pendulum Animation
L = 150
g = 9.81
theta0 = 1
// Pendulum bob
x = L * sin(theta0 * cos(sqrt(g/L) * t))
y = -L * cos(theta0 * cos(sqrt(g/L) * t))
line(0, 0, x, y, 'brown', 3)
circle(x, y, 10, 'red', true)
circle(0, 0, 3, 'black', true)
// Trace path
parametric('L*sin(theta0*cos(sqrt(g/L)*t))', '-L*cos(theta0*cos(sqrt(g/L)*t))', 0, t, 'lightblue', 1)`,

            // Complex plane
            `// Complex Number Visualization
// Unit circle
circle(0, 0, 100, 'black', false, 2)
// Complex numbers
z1_re = 50
z1_im = 50
z2_re = -30
z2_im = 70
arrow(0, 0, z1_re, z1_im, 'red', 2)
arrow(0, 0, z2_re, z2_im, 'blue', 2)
text(z1_re+10, z1_im, 'z1', 'red', 12)
text(z2_re-20, z2_im, 'z2', 'blue', 12)
line(-150, 0, 150, 0, 'gray', 1)
line(0, -150, 0, 150, 'gray', 1)`
        ];

        function loadExample(index) {
            if (index < examples.length) {
                document.getElementById('commandInput').value = examples[index];
                executeCommands();
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key) {
                    case 'Enter':
                        e.preventDefault();
                        executeCommands();
                        break;
                    case 'l':
                        e.preventDefault();
                        clearCanvas();
                        break;
                    case 's':
                        e.preventDefault();
                        saveCanvas();
                        break;
                }
            }
        });

        // Initialize when page loads
        window.onload = initSystem;

        // Make functions globally accessible
        window.executeCommands = executeCommands;
        window.clearCanvas = clearCanvas;
        window.saveCanvas = saveCanvas;
        window.toggleAnimation = toggleAnimation;
        window.pauseAnimation = pauseAnimation;
        window.resetAnimation = resetAnimation;
        window.toggleGrid = toggleGrid;
        window.toggleAxes = toggleAxes;
        window.loadExample = loadExample;
    </script>
</body>
</html>